import type {
  DatabaseResult,
  Model,
  Query,
  ResultRecord,
  Statement,
  StoredObject,
} from 'blade-compiler';

import type { TriggerOptions, Triggers } from '@/src/triggers';
import type { StorableObject } from '@/src/types/storage';

export interface QueryHandlerOptions {
  /**
   * Object containing triggers for defined schemas.
   */
  triggers?: Triggers;

  /**
   * Specific query types for which "during" triggers should be required.
   */
  requireTriggers?: 'all' | 'write' | 'read';

  /**
   * Token used to authenticate against RONIN. By default,
   * `process.env.RONIN_TOKEN` will be used.
   */
  token?: string;

  /**
   * Allows for executing SQL statements generated by the client.
   *
   * @param statements - An array of SQL statements to execute.
   * @param options - Additional configuration for the database call.
   *
   * @returns A promise that resolves with the result of the SQL statements.
   */
  databaseCaller?: (
    statements: Array<Statement>,
    options: { token: string; database: string; stream: boolean },
  ) => Promise<DatabaseResult> | DatabaseResult;

  /**
   * Allows for uploading storage objects provided to the client.
   *
   * @param object - The object to upload.
   * @param options - Additional configuration for the storage call.
   *
   * @returns A promise that resolves with a reference to the uploaded object.
   */
  storageCaller?: (
    object: StorableObject,
    options: { token: string },
  ) => Promise<StoredObject> | StoredObject;

  /**
   * Invoked by the query syntax when queries are to be executed.
   *
   * @param queries - A list of queries that should be executed.
   * @param options - Configuration options that were provided for the queries.
   *
   * @returns Formatted results for the provided queries.
   */
  syntaxCallback?: (
    queries: Array<Query>,
    options: QueryHandlerOptions,
  ) => Promise<FormattedResults<ResultRecord>>;

  /**
   * A particular connection identifier to re-use for the provided queries.
   *
   * Useful for ensuring that multiple transactions are sent through the same connection,
   * which guarantees their order during transport.
   */
  stream?: string;

  /**
   * Allows for extending the lifetime of the edge worker invocation until the
   * provided promise has been resolved. If the `triggers` option is provided on
   * an edge runtime, this option is required.
   */
  waitUntil?: (promise: Promise<unknown>) => void;

  /**
   * If the query should be run for a specific database within your space, you may
   * provide the desired database name here.
   */
  database?: string;

  /**
   * Allows for indicating whether the client is being invoked from inside of a trigger,
   * which lets the client ensure that the trigger is not invoked recursively.
   *
   * It is highly recommended to rely on `options.client` for running queries in triggers
   * instead of initializing a custom client, as that resumes the configuration.
   */
  parentTrigger?: TriggerOptions['parentTrigger'];

  /** A list of models used for compiling Blade queries to SQL. */
  models?: Array<Model>;

  /**
   * Applies a default `limitedTo` instruction to queries obtaining multiple records.
   * Useful for environments in which memory is tightly constrained.
   */
  defaultRecordLimit?: number;

  /** Log helpful debugging information. */
  debug?: boolean;
}

/**
 * Utility type to make all properties of an object optional.
 */
export type RecursivePartial<T> = {
  [K in keyof T]?: T[K] extends Array<infer U>
    ? Array<RecursivePartial<U>>
    : T[K] extends object
      ? RecursivePartial<T[K]>
      : T[K];
};

/**
 * Utility type to convert a tuple of promises into a tuple of their resolved types.
 */
export type PromiseTuple<
  T extends [Promise<any>, ...Array<Promise<any>>] | Array<Promise<any>>,
> = {
  [P in keyof T]: Awaited<T[P]>;
};

export type RegularFormattedResult<T> =
  | number
  | (T & ResultRecord)
  | (Array<T & ResultRecord> & { moreBefore?: string; moreAfter?: string })
  | null;

export type ExpandedFormattedResult<T> = Record<Model['slug'], RegularFormattedResult<T>>;

type FormattedResult<T> = RegularFormattedResult<T> | ExpandedFormattedResult<T>;

export type FormattedResults<T> = Array<FormattedResult<T>>;
