import bcrypt from 'bcryptjs';
import {
  EmptyFieldsError,
  InvalidFieldsError,
  MultipleWithInstructionsError,
  RecordNotFoundError,
  SetNotAllowedError,
  TooManyRequestsError,
} from 'blade/server/errors';
import type { Account, AddTrigger, RemoveTrigger, SetTrigger } from 'blade/types';

import {
  EMAIL_VERIFICATION_COOLDOWN,
  PASSWORD_HASH_LENGTH,
  avoidEmptyFields,
  generateUniqueId,
} from '@/utils/index';
import type { WithAuthOptions } from '@/utils/types';

export const add: AddTrigger = async (query) => {
  // @ts-expect-error - Types need to be improved.
  Object.assign(query.with, {
    // @ts-expect-error - Types need to be improved.
    password: await bcrypt.hash(query.with.password, PASSWORD_HASH_LENGTH),

    emailVerified: false,
    emailVerificationToken: generateUniqueId(24),
    emailVerificationSentAt: new Date().toISOString(),
  });

  return query;
};

export const remove: RemoveTrigger = (query) => query;

export const set: WithAuthOptions<SetTrigger> = async (
  query,
  _multiple,
  options,
  auth,
) => {
  const { get } = options.client;

  if (!query.with) throw new Error('A `with` instruction must be given.');
  if (!query.to) throw new Error('A `to` instruction must be given.');

  if (Array.isArray(query.with)) throw new MultipleWithInstructionsError();

  avoidEmptyFields(query.to, ['password']);

  // These actions are arranged in the order in which they are executed after a
  // new account is created.
  const operation = query.to.emailVerificationSentAt
    ? 'EMAIL_VERIFICATION_RESEND'
    : query.to.emailVerified === true
      ? 'EMAIL_VERIFICATION_DONE'
      : query.to.password === null
        ? 'PASSWORD_RESET'
        : query.to.password && query.with?.emailVerificationToken
          ? 'PASSWORD_RESET_DONE'
          : query.to.password
            ? 'PASSWORD_CHANGE'
            : null;

  if (
    // These operations should work without an active session.
    operation === 'EMAIL_VERIFICATION_RESEND' ||
    operation === 'EMAIL_VERIFICATION_DONE' ||
    operation === 'PASSWORD_RESET' ||
    operation === 'PASSWORD_RESET_DONE'
  ) {
    // However, completing any of the aforementioned processes, meaning completing the
    // email verification or the password reset, should only be possible with the right
    // email verification token.
    if (!(operation === 'EMAIL_VERIFICATION_RESEND' || operation === 'PASSWORD_RESET')) {
      const { emailVerificationToken } = query.with || {};

      if (!emailVerificationToken) {
        throw new EmptyFieldsError({
          message:
            'For this action, the field `with.emailVerificationToken` must be provided.',
          fields: ['emailVerificationToken'],
        });
      }

      const account = await get.account.with({ emailVerificationToken });

      if (!account) {
        throw new InvalidFieldsError({ fields: ['id', 'currentPassword'] });
      }

      (query.to.ronin as Record<string, string>).updatedBy = account.id as string;
    }
  } else {
    // TODO: Check to make sure the user has permission to update / delete an account.
  }

  if (operation)
    console.debug(
      `Performing \`${operation}\` on selector \`${JSON.stringify(query.with)}\``,
    );

  // `currentPassword` is an ephemeral field, so we want to delete it before letting
  // Blade update the record.
  const currentPassword = query.to.currentPassword;
  delete query.to.currentPassword;

  if (currentPassword && !query.to.password) {
    throw new EmptyFieldsError({ fields: ['password'] });
  }

  // Don't allow `emailVerificationToken` to be written to. We do this in order to
  // prevent anyone setting a custom `emailVerificationToken`. A new
  // `emailVerificationToken` can only be generated by setting `emailVerificationSentAt`.
  // This intentionally throws an `InvalidFieldsError` to completely hide the existence
  // of this field from the outside.
  if (query.to.emailVerificationToken) {
    throw new InvalidFieldsError({ fields: ['emailVerificationToken'] });
  }

  if (operation === 'EMAIL_VERIFICATION_DONE') {
    const account = (await get.account.with.id(query.with.id as string)) as Account;

    if (!account)
      throw new RecordNotFoundError({
        message: 'Account subject to verification does not exist.',
      });

    if (account.emailVerificationToken !== query.with?.emailVerificationToken) {
      throw new InvalidFieldsError({
        message: 'Invalid verification token provided.',
        fields: ['emailVerificationToken'],
      });
    }

    // Abort if the account already has a verified email address.
    if (account.emailVerified) {
      throw new SetNotAllowedError({
        message: 'This account already has a verified email address.',
      });
    }
  }

  if (operation === 'EMAIL_VERIFICATION_RESEND' || operation === 'PASSWORD_RESET') {
    const account = (await get.account.with(query.with)) as Account;

    // Abort if no matching account was found for the provided query.
    if (!account) {
      throw new RecordNotFoundError({ fields: ['email'] });
    }

    // Abort if the account already has a verified email address.
    if (operation === 'EMAIL_VERIFICATION_RESEND' && account.emailVerified) {
      throw new SetNotAllowedError({
        message: 'This account already has a verified email address.',
      });
    }

    const newDate = query.to.emailVerificationSentAt
      ? new Date(query.to.emailVerificationSentAt as string)
      : new Date();
    const previousDate = new Date(account.emailVerificationSentAt);

    // Don't send another verification email if `emailVerificationSentAt` is
    // set to the past.
    if (newDate < previousDate) {
      throw new InvalidFieldsError({
        message:
          'The date provided for `emailVerificationSentAt` must not be in the past.',
        fields: ['emailVerificationSentAt'],
      });
    }

    // Don't allow sending new emails too quickly, in order to not spam the email
    // provider and decrease the email reputation.
    if (newDate.getTime() < previousDate.getTime() + EMAIL_VERIFICATION_COOLDOWN) {
      throw new TooManyRequestsError({ fields: ['emailVerificationSentAt'] });
    }

    const verificationToken = generateUniqueId(24);

    if (operation === 'PASSWORD_RESET') {
      await auth.sendEmail?.({
        account,
        type: 'PASSWORD_RESET',
        token: verificationToken,
      });
    }

    if (operation === 'EMAIL_VERIFICATION_RESEND') {
      await auth.sendEmail?.({
        account,
        type: 'EMAIL_VERIFICATION',
        token: verificationToken,
      });
    }

    query.to = {
      ...query.to,
      emailVerificationToken: verificationToken,
      emailVerificationSentAt: newDate,
    };
  }

  if (operation === 'PASSWORD_CHANGE' || operation === 'PASSWORD_RESET_DONE') {
    avoidEmptyFields(query.to);

    if (operation === 'PASSWORD_CHANGE') {
      const match = (await get.account.with(query.with)) as Account;

      if (!(query.with?.emailVerificationToken || currentPassword)) {
        throw new EmptyFieldsError({ fields: ['currentPassword'] });
      }

      if (
        !(
          // Abort if no matching account was found for the provided query.
          (
            match &&
            // Abort if the provided `currentPassword` doesn't match the account's
            // stored password.
            //
            // If a matching `emailVerificationToken` is provided, however, we don't need
            // to compare the passwords, because in that case the password is being reset
            // (the old password is not known in such a case).
            (query.with?.emailVerificationToken ||
              (await bcrypt.compare(match.password || '', currentPassword as string)))
          )
        )
      ) {
        throw new InvalidFieldsError({ fields: ['id', 'currentPassword'] });
      }
    }

    query.to.password = await bcrypt.hash(
      query.to.password as string,
      PASSWORD_HASH_LENGTH,
    );
  } else {
    // Don't allow writing `password` unless a password change was requested.
    delete query.to.password;
  }

  return query;
};
