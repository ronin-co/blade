// Bun Snapshot v1, https://bun.sh/docs/test/snapshots

exports[`generate a basic model 1`] = `
"import type { CombinedInstructions, Expression } from "blade-compiler";
import type { ReducedFunction } from "blade/types";
import type { Account, Accounts } from "blade/types";
export type { Account, Accounts };
declare namespace Utils {
    type AfterQuery<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["after"], options?: Record<string, unknown>) => T);
    type AfterQueryPromise<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["after"], options?: Record<string, unknown>) => Promise<T>);
    type BeforeQuery<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["before"], options?: Record<string, unknown>) => T);
    type BeforeQueryPromise<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["before"], options?: Record<string, unknown>) => Promise<T>);
    type IncludingQuery<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["including"], options?: Record<string, unknown>) => T);
    type IncludingQueryPromise<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["including"], options?: Record<string, unknown>) => Promise<T>);
    type LimitedToQuery<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["limitedTo"], options?: Record<string, unknown>) => T);
    type LimitedToQueryPromise<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["limitedTo"], options?: Record<string, unknown>) => Promise<T>);
    type OrderedByQuery<U, F extends string> = ReducedFunction & (<T = U>(instructions: {
        ascending?: Array<Expression | F>;
        descending?: Array<Expression | F>;
    }, options?: Record<string, unknown>) => T) & {
        ascending: <T = U>(fields: Array<Expression | F>, options?: Record<string, unknown>) => T;
        descending: <T = U>(fields: Array<Expression | F>, options?: Record<string, unknown>) => T;
    };
    type OrderedByQueryPromise<U, F extends string> = ReducedFunction & (<T = U>(instructions: {
        ascending?: Array<Expression | F>;
        descending?: Array<Expression | F>;
    }, options?: Record<string, unknown>) => Promise<T>) & {
        ascending: <T = U>(fields: Array<Expression | F>, options?: Record<string, unknown>) => Promise<T>;
        descending: <T = U>(fields: Array<Expression | F>, options?: Record<string, unknown>) => Promise<T>;
    };
    type ResultRecord = {
        /* The unique identifier of the record. */
        id: string;
        ronin: {
            /* The timestamp of when the record was created. */
            createdAt: string;
            /* The ID of the user who created the record. */
            createdBy: string | null;
            /* The timestamp of the last time the record was updated. */
            updatedAt: string;
            /* The ID of the user who last updated the record. */
            updatedBy: string | null;
        };
    };
    type RootQueryCaller<U> = <T = U>(instructions?: Partial<CombinedInstructions>, options?: Record<string, unknown>) => T;
    type RootQueryCallerPromise<U> = <T = U>(instructions?: Partial<CombinedInstructions>, options?: Record<string, unknown>) => Promise<T>;
    type SelectingQuery<U, F> = ReducedFunction & (<T = U>(instructions: Array<F>, options?: Record<string, unknown>) => T);
    type SelectingQueryPromise<U, F> = ReducedFunction & (<T = U>(instructions: Array<F>, options?: Record<string, unknown>) => Promise<T>);
    type ToQuery<U, S> = ReducedFunction & (<T = U>(instructions: Partial<S>, options?: Record<string, unknown>) => T);
    type ToQueryPromise<U, S> = ReducedFunction & (<T = U>(instructions: Partial<S>, options?: Record<string, unknown>) => Promise<T>);
    type WithQuery<U, S> = ReducedFunction & {
        <T = U>(instructions: Partial<S> | CombinedInstructions["with"], options?: Record<string, unknown>): T;
        id: <T = U>(value: ResultRecord["id"], options?: Record<string, unknown>) => T;
        ronin: ReducedFunction & {
            createdAt: <T = U>(value: ResultRecord["ronin"]["createdAt"], options?: Record<string, unknown>) => T;
            createdBy: <T = U>(value: ResultRecord["ronin"]["createdBy"], options?: Record<string, unknown>) => T;
            updatedAt: <T = U>(value: ResultRecord["ronin"]["updatedAt"], options?: Record<string, unknown>) => T;
            updatedBy: <T = U>(value: ResultRecord["ronin"]["updatedBy"], options?: Record<string, unknown>) => T;
        };
    };
    type WithQueryPromise<U, S> = ReducedFunction & {
        <T = U>(instructions: Partial<S> | CombinedInstructions["with"], options?: Record<string, unknown>): Promise<T>;
        id: <T = U>(value: ResultRecord["id"], options?: Record<string, unknown>) => Promise<T>;
        ronin: ReducedFunction & {
            createdAt: <T = U>(value: ResultRecord["ronin"]["createdAt"], options?: Record<string, unknown>) => Promise<T>;
            createdBy: <T = U>(value: ResultRecord["ronin"]["createdBy"], options?: Record<string, unknown>) => Promise<T>;
            updatedAt: <T = U>(value: ResultRecord["ronin"]["updatedAt"], options?: Record<string, unknown>) => Promise<T>;
            updatedBy: <T = U>(value: ResultRecord["ronin"]["updatedBy"], options?: Record<string, unknown>) => Promise<T>;
        };
    };
}
declare namespace Syntax {
    type AddQuery = {
        /** Add a single account record */
        account: ReducedFunction & Syntax.Account.Singular.RootQueryCallerPromise & {
            after: Syntax.Account.Singular.AfterQueryPromise;
            before: Syntax.Account.Singular.BeforeQueryPromise;
            including: Syntax.Account.Singular.IncludingQueryPromise;
            limitedTo: Syntax.Account.Singular.LimitedToQueryPromise;
            orderedBy: Syntax.Account.Singular.OrderedByQueryPromise;
            selecting: Syntax.Account.Singular.SelectingQueryPromise;
            to: Syntax.Account.Singular.ToQueryPromise;
            using: Syntax.Account.Singular.UsingQueryPromise;
            with: Syntax.Account.Singular.WithQueryPromise;
        };
        /** Add multiple account records */
        accounts: ReducedFunction & Syntax.Account.Plural.RootQueryCallerPromise & {
            after: Syntax.Account.Plural.AfterQueryPromise;
            before: Syntax.Account.Plural.BeforeQueryPromise;
            including: Syntax.Account.Plural.IncludingQueryPromise;
            limitedTo: Syntax.Account.Plural.LimitedToQueryPromise;
            orderedBy: Syntax.Account.Plural.OrderedByQueryPromise;
            selecting: Syntax.Account.Plural.SelectingQueryPromise;
            to: Syntax.Account.Plural.ToQueryPromise;
            using: Syntax.Account.Plural.UsingQueryPromise;
            with: Syntax.Account.Plural.WithQueryPromise;
        };
    };
    type GetQuery = {
        /** Get a single account record */
        account: ReducedFunction & Syntax.Account.Singular.RootQueryCaller & {
            after: Syntax.Account.Singular.AfterQuery;
            before: Syntax.Account.Singular.BeforeQuery;
            including: Syntax.Account.Singular.IncludingQuery;
            limitedTo: Syntax.Account.Singular.LimitedToQuery;
            orderedBy: Syntax.Account.Singular.OrderedByQuery;
            selecting: Syntax.Account.Singular.SelectingQuery;
            using: Syntax.Account.Singular.UsingQuery;
            with: Syntax.Account.Singular.WithQuery;
        };
        /** Get multiple account records */
        accounts: ReducedFunction & Syntax.Account.Plural.RootQueryCaller & {
            after: Syntax.Account.Plural.AfterQuery;
            before: Syntax.Account.Plural.BeforeQuery;
            including: Syntax.Account.Plural.IncludingQuery;
            limitedTo: Syntax.Account.Plural.LimitedToQuery;
            orderedBy: Syntax.Account.Plural.OrderedByQuery;
            selecting: Syntax.Account.Plural.SelectingQuery;
            using: Syntax.Account.Plural.UsingQuery;
            with: Syntax.Account.Plural.WithQuery;
        };
    };
    type RemoveQuery = {
        /** Remove a single account record */
        account: ReducedFunction & Syntax.Account.Singular.RootQueryCallerPromise & {
            after: Syntax.Account.Singular.AfterQueryPromise;
            before: Syntax.Account.Singular.BeforeQueryPromise;
            including: Syntax.Account.Singular.IncludingQueryPromise;
            limitedTo: Syntax.Account.Singular.LimitedToQueryPromise;
            orderedBy: Syntax.Account.Singular.OrderedByQueryPromise;
            selecting: Syntax.Account.Singular.SelectingQueryPromise;
            to: Syntax.Account.Singular.ToQueryPromise;
            using: Syntax.Account.Singular.UsingQueryPromise;
            with: Syntax.Account.Singular.WithQueryPromise;
        };
        /** Remove multiple account records */
        accounts: ReducedFunction & Syntax.Account.Plural.RootQueryCallerPromise & {
            after: Syntax.Account.Plural.AfterQueryPromise;
            before: Syntax.Account.Plural.BeforeQueryPromise;
            including: Syntax.Account.Plural.IncludingQueryPromise;
            limitedTo: Syntax.Account.Plural.LimitedToQueryPromise;
            orderedBy: Syntax.Account.Plural.OrderedByQueryPromise;
            selecting: Syntax.Account.Plural.SelectingQueryPromise;
            to: Syntax.Account.Plural.ToQueryPromise;
            using: Syntax.Account.Plural.UsingQueryPromise;
            with: Syntax.Account.Plural.WithQueryPromise;
        };
    };
    type SetQuery = {
        /** Set a single account record */
        account: ReducedFunction & Syntax.Account.Singular.RootQueryCallerPromise & {
            after: Syntax.Account.Singular.AfterQueryPromise;
            before: Syntax.Account.Singular.BeforeQueryPromise;
            including: Syntax.Account.Singular.IncludingQueryPromise;
            limitedTo: Syntax.Account.Singular.LimitedToQueryPromise;
            orderedBy: Syntax.Account.Singular.OrderedByQueryPromise;
            selecting: Syntax.Account.Singular.SelectingQueryPromise;
            to: Syntax.Account.Singular.ToQueryPromise;
            using: Syntax.Account.Singular.UsingQueryPromise;
            with: Syntax.Account.Singular.WithQueryPromise;
        };
        /** Set multiple account records */
        accounts: ReducedFunction & Syntax.Account.Plural.RootQueryCallerPromise & {
            after: Syntax.Account.Plural.AfterQueryPromise;
            before: Syntax.Account.Plural.BeforeQueryPromise;
            including: Syntax.Account.Plural.IncludingQueryPromise;
            limitedTo: Syntax.Account.Plural.LimitedToQueryPromise;
            orderedBy: Syntax.Account.Plural.OrderedByQueryPromise;
            selecting: Syntax.Account.Plural.SelectingQueryPromise;
            to: Syntax.Account.Plural.ToQueryPromise;
            using: Syntax.Account.Plural.UsingQueryPromise;
            with: Syntax.Account.Plural.WithQueryPromise;
        };
    };
    namespace Account {
        type FieldSlug = "id" | "ronin.createdAt" | "ronin.createdBy" | "ronin.updatedAt" | "ronin.updatedBy" | "name" | "email";
        namespace Singular {
            type AfterQuery = Utils.AfterQuery<Account | null>;
            type AfterQueryPromise = Utils.AfterQueryPromise<Account | null>;
            type BeforeQuery = Utils.BeforeQuery<Account | null>;
            type BeforeQueryPromise = Utils.BeforeQueryPromise<Account | null>;
            type IncludingQuery = Utils.IncludingQuery<Account | null>;
            type IncludingQueryPromise = Utils.IncludingQueryPromise<Account | null>;
            type LimitedToQuery = Utils.LimitedToQuery<Account | null>;
            type LimitedToQueryPromise = Utils.LimitedToQueryPromise<Account | null>;
            type OrderedByQuery = Utils.OrderedByQuery<Account | null, Account.FieldSlug>;
            type OrderedByQueryPromise = Utils.OrderedByQueryPromise<Account | null, Account.FieldSlug>;
            type RootQueryCaller = Utils.RootQueryCaller<Account | null>;
            type RootQueryCallerPromise = Utils.RootQueryCallerPromise<Account | null>;
            type SelectingQuery = Utils.SelectingQuery<Account | null, Account.FieldSlug>;
            type SelectingQueryPromise = Utils.SelectingQueryPromise<Account | null, Account.FieldSlug>;
            type ToQuery = Utils.ToQuery<Account | null, Account>;
            type ToQueryPromise = Utils.ToQueryPromise<Account | null, Account>;
            type UsingQuery = ReducedFunction & (<T = Account | null>(value: CombinedInstructions["using"]) => T);
            type UsingQueryPromise = ReducedFunction & (<T = Account | null>(value: CombinedInstructions["using"]) => Promise<T>);
            type WithQuery = Utils.WithQuery<Account | null, Account> & {
                name: <T = Account | null>(name: Account["name"], options?: Record<string, unknown>) => T;
                email: <T = Account | null>(email: Account["email"], options?: Record<string, unknown>) => T;
            };
            type WithQueryPromise = Utils.WithQueryPromise<Account | null, Account> & {
                name: <T = Account | null>(name: Account["name"], options?: Record<string, unknown>) => Promise<T>;
                email: <T = Account | null>(email: Account["email"], options?: Record<string, unknown>) => Promise<T>;
            };
        }
        namespace Plural {
            type AfterQuery = Utils.AfterQuery<Accounts>;
            type AfterQueryPromise = Utils.AfterQueryPromise<Accounts>;
            type BeforeQuery = Utils.BeforeQuery<Accounts>;
            type BeforeQueryPromise = Utils.BeforeQueryPromise<Accounts>;
            type IncludingQuery = Utils.IncludingQuery<Accounts>;
            type IncludingQueryPromise = Utils.IncludingQueryPromise<Accounts>;
            type LimitedToQuery = Utils.LimitedToQuery<Accounts>;
            type LimitedToQueryPromise = Utils.LimitedToQueryPromise<Accounts>;
            type OrderedByQuery = Utils.OrderedByQuery<Accounts, Account.FieldSlug>;
            type OrderedByQueryPromise = Utils.OrderedByQueryPromise<Accounts, Account.FieldSlug>;
            type RootQueryCaller = Utils.RootQueryCaller<Accounts>;
            type RootQueryCallerPromise = Utils.RootQueryCallerPromise<Accounts>;
            type SelectingQuery = Utils.SelectingQuery<Accounts, Account.FieldSlug>;
            type SelectingQueryPromise = Utils.SelectingQueryPromise<Accounts, Account.FieldSlug>;
            type ToQuery = Utils.ToQuery<Accounts, Account>;
            type ToQueryPromise = Utils.ToQueryPromise<Accounts, Account>;
            type UsingQuery = ReducedFunction & (<T = Accounts>(value: CombinedInstructions["using"]) => T);
            type UsingQueryPromise = ReducedFunction & (<T = Accounts>(value: CombinedInstructions["using"]) => Promise<T>);
            type WithQuery = Utils.WithQuery<Accounts, Account> & {
                name: <T = Accounts>(name: Account["name"], options?: Record<string, unknown>) => T;
                email: <T = Accounts>(email: Account["email"], options?: Record<string, unknown>) => T;
            };
            type WithQueryPromise = Utils.WithQueryPromise<Accounts, Account> & {
                name: <T = Accounts>(name: Account["name"], options?: Record<string, unknown>) => Promise<T>;
                email: <T = Accounts>(email: Account["email"], options?: Record<string, unknown>) => Promise<T>;
            };
        }
    }
}
declare module "blade/types" {
    export interface TriggerOptions {
        client: {
            add: Syntax.AddQuery;
            get: Syntax.GetQuery;
            remove: Syntax.RemoveQuery;
            set: Syntax.SetQuery;
        };
    }
    export type Account = Utils.ResultRecord & {
        email: string;
        name: string;
    };
    export type Accounts = Array<Account> & {
        moreBefore?: string;
        moreAfter?: string;
    };
}
declare module "blade/server/hooks" {
    declare const use: Syntax.GetQuery;
}
declare module "blade/client/hooks" {
    declare const useMutation: () => {
        add: Syntax.AddQuery;
        remove: Syntax.RemoveQuery;
        set: Syntax.SetQuery;
    };
}
"
`;

exports[`generate a basic model with blob field 1`] = `
"import type { CombinedInstructions, Expression } from "blade-compiler";
import type { ReducedFunction } from "blade/types";
import type { StoredObject } from "blade-compiler";
import type { Account, Accounts } from "blade/types";
export type { Account, Accounts };
declare namespace Utils {
    type AfterQuery<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["after"], options?: Record<string, unknown>) => T);
    type AfterQueryPromise<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["after"], options?: Record<string, unknown>) => Promise<T>);
    type BeforeQuery<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["before"], options?: Record<string, unknown>) => T);
    type BeforeQueryPromise<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["before"], options?: Record<string, unknown>) => Promise<T>);
    type IncludingQuery<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["including"], options?: Record<string, unknown>) => T);
    type IncludingQueryPromise<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["including"], options?: Record<string, unknown>) => Promise<T>);
    type LimitedToQuery<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["limitedTo"], options?: Record<string, unknown>) => T);
    type LimitedToQueryPromise<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["limitedTo"], options?: Record<string, unknown>) => Promise<T>);
    type OrderedByQuery<U, F extends string> = ReducedFunction & (<T = U>(instructions: {
        ascending?: Array<Expression | F>;
        descending?: Array<Expression | F>;
    }, options?: Record<string, unknown>) => T) & {
        ascending: <T = U>(fields: Array<Expression | F>, options?: Record<string, unknown>) => T;
        descending: <T = U>(fields: Array<Expression | F>, options?: Record<string, unknown>) => T;
    };
    type OrderedByQueryPromise<U, F extends string> = ReducedFunction & (<T = U>(instructions: {
        ascending?: Array<Expression | F>;
        descending?: Array<Expression | F>;
    }, options?: Record<string, unknown>) => Promise<T>) & {
        ascending: <T = U>(fields: Array<Expression | F>, options?: Record<string, unknown>) => Promise<T>;
        descending: <T = U>(fields: Array<Expression | F>, options?: Record<string, unknown>) => Promise<T>;
    };
    type ResultRecord = {
        /* The unique identifier of the record. */
        id: string;
        ronin: {
            /* The timestamp of when the record was created. */
            createdAt: string;
            /* The ID of the user who created the record. */
            createdBy: string | null;
            /* The timestamp of the last time the record was updated. */
            updatedAt: string;
            /* The ID of the user who last updated the record. */
            updatedBy: string | null;
        };
    };
    type RootQueryCaller<U> = <T = U>(instructions?: Partial<CombinedInstructions>, options?: Record<string, unknown>) => T;
    type RootQueryCallerPromise<U> = <T = U>(instructions?: Partial<CombinedInstructions>, options?: Record<string, unknown>) => Promise<T>;
    type SelectingQuery<U, F> = ReducedFunction & (<T = U>(instructions: Array<F>, options?: Record<string, unknown>) => T);
    type SelectingQueryPromise<U, F> = ReducedFunction & (<T = U>(instructions: Array<F>, options?: Record<string, unknown>) => Promise<T>);
    type ToQuery<U, S> = ReducedFunction & (<T = U>(instructions: Partial<S>, options?: Record<string, unknown>) => T);
    type ToQueryPromise<U, S> = ReducedFunction & (<T = U>(instructions: Partial<S>, options?: Record<string, unknown>) => Promise<T>);
    type WithQuery<U, S> = ReducedFunction & {
        <T = U>(instructions: Partial<S> | CombinedInstructions["with"], options?: Record<string, unknown>): T;
        id: <T = U>(value: ResultRecord["id"], options?: Record<string, unknown>) => T;
        ronin: ReducedFunction & {
            createdAt: <T = U>(value: ResultRecord["ronin"]["createdAt"], options?: Record<string, unknown>) => T;
            createdBy: <T = U>(value: ResultRecord["ronin"]["createdBy"], options?: Record<string, unknown>) => T;
            updatedAt: <T = U>(value: ResultRecord["ronin"]["updatedAt"], options?: Record<string, unknown>) => T;
            updatedBy: <T = U>(value: ResultRecord["ronin"]["updatedBy"], options?: Record<string, unknown>) => T;
        };
    };
    type WithQueryPromise<U, S> = ReducedFunction & {
        <T = U>(instructions: Partial<S> | CombinedInstructions["with"], options?: Record<string, unknown>): Promise<T>;
        id: <T = U>(value: ResultRecord["id"], options?: Record<string, unknown>) => Promise<T>;
        ronin: ReducedFunction & {
            createdAt: <T = U>(value: ResultRecord["ronin"]["createdAt"], options?: Record<string, unknown>) => Promise<T>;
            createdBy: <T = U>(value: ResultRecord["ronin"]["createdBy"], options?: Record<string, unknown>) => Promise<T>;
            updatedAt: <T = U>(value: ResultRecord["ronin"]["updatedAt"], options?: Record<string, unknown>) => Promise<T>;
            updatedBy: <T = U>(value: ResultRecord["ronin"]["updatedBy"], options?: Record<string, unknown>) => Promise<T>;
        };
    };
}
declare namespace Syntax {
    type AddQuery = {
        /** Add a single account record */
        account: ReducedFunction & Syntax.Account.Singular.RootQueryCallerPromise & {
            after: Syntax.Account.Singular.AfterQueryPromise;
            before: Syntax.Account.Singular.BeforeQueryPromise;
            including: Syntax.Account.Singular.IncludingQueryPromise;
            limitedTo: Syntax.Account.Singular.LimitedToQueryPromise;
            orderedBy: Syntax.Account.Singular.OrderedByQueryPromise;
            selecting: Syntax.Account.Singular.SelectingQueryPromise;
            to: Syntax.Account.Singular.ToQueryPromise;
            using: Syntax.Account.Singular.UsingQueryPromise;
            with: Syntax.Account.Singular.WithQueryPromise;
        };
        /** Add multiple account records */
        accounts: ReducedFunction & Syntax.Account.Plural.RootQueryCallerPromise & {
            after: Syntax.Account.Plural.AfterQueryPromise;
            before: Syntax.Account.Plural.BeforeQueryPromise;
            including: Syntax.Account.Plural.IncludingQueryPromise;
            limitedTo: Syntax.Account.Plural.LimitedToQueryPromise;
            orderedBy: Syntax.Account.Plural.OrderedByQueryPromise;
            selecting: Syntax.Account.Plural.SelectingQueryPromise;
            to: Syntax.Account.Plural.ToQueryPromise;
            using: Syntax.Account.Plural.UsingQueryPromise;
            with: Syntax.Account.Plural.WithQueryPromise;
        };
    };
    type GetQuery = {
        /** Get a single account record */
        account: ReducedFunction & Syntax.Account.Singular.RootQueryCaller & {
            after: Syntax.Account.Singular.AfterQuery;
            before: Syntax.Account.Singular.BeforeQuery;
            including: Syntax.Account.Singular.IncludingQuery;
            limitedTo: Syntax.Account.Singular.LimitedToQuery;
            orderedBy: Syntax.Account.Singular.OrderedByQuery;
            selecting: Syntax.Account.Singular.SelectingQuery;
            using: Syntax.Account.Singular.UsingQuery;
            with: Syntax.Account.Singular.WithQuery;
        };
        /** Get multiple account records */
        accounts: ReducedFunction & Syntax.Account.Plural.RootQueryCaller & {
            after: Syntax.Account.Plural.AfterQuery;
            before: Syntax.Account.Plural.BeforeQuery;
            including: Syntax.Account.Plural.IncludingQuery;
            limitedTo: Syntax.Account.Plural.LimitedToQuery;
            orderedBy: Syntax.Account.Plural.OrderedByQuery;
            selecting: Syntax.Account.Plural.SelectingQuery;
            using: Syntax.Account.Plural.UsingQuery;
            with: Syntax.Account.Plural.WithQuery;
        };
    };
    type RemoveQuery = {
        /** Remove a single account record */
        account: ReducedFunction & Syntax.Account.Singular.RootQueryCallerPromise & {
            after: Syntax.Account.Singular.AfterQueryPromise;
            before: Syntax.Account.Singular.BeforeQueryPromise;
            including: Syntax.Account.Singular.IncludingQueryPromise;
            limitedTo: Syntax.Account.Singular.LimitedToQueryPromise;
            orderedBy: Syntax.Account.Singular.OrderedByQueryPromise;
            selecting: Syntax.Account.Singular.SelectingQueryPromise;
            to: Syntax.Account.Singular.ToQueryPromise;
            using: Syntax.Account.Singular.UsingQueryPromise;
            with: Syntax.Account.Singular.WithQueryPromise;
        };
        /** Remove multiple account records */
        accounts: ReducedFunction & Syntax.Account.Plural.RootQueryCallerPromise & {
            after: Syntax.Account.Plural.AfterQueryPromise;
            before: Syntax.Account.Plural.BeforeQueryPromise;
            including: Syntax.Account.Plural.IncludingQueryPromise;
            limitedTo: Syntax.Account.Plural.LimitedToQueryPromise;
            orderedBy: Syntax.Account.Plural.OrderedByQueryPromise;
            selecting: Syntax.Account.Plural.SelectingQueryPromise;
            to: Syntax.Account.Plural.ToQueryPromise;
            using: Syntax.Account.Plural.UsingQueryPromise;
            with: Syntax.Account.Plural.WithQueryPromise;
        };
    };
    type SetQuery = {
        /** Set a single account record */
        account: ReducedFunction & Syntax.Account.Singular.RootQueryCallerPromise & {
            after: Syntax.Account.Singular.AfterQueryPromise;
            before: Syntax.Account.Singular.BeforeQueryPromise;
            including: Syntax.Account.Singular.IncludingQueryPromise;
            limitedTo: Syntax.Account.Singular.LimitedToQueryPromise;
            orderedBy: Syntax.Account.Singular.OrderedByQueryPromise;
            selecting: Syntax.Account.Singular.SelectingQueryPromise;
            to: Syntax.Account.Singular.ToQueryPromise;
            using: Syntax.Account.Singular.UsingQueryPromise;
            with: Syntax.Account.Singular.WithQueryPromise;
        };
        /** Set multiple account records */
        accounts: ReducedFunction & Syntax.Account.Plural.RootQueryCallerPromise & {
            after: Syntax.Account.Plural.AfterQueryPromise;
            before: Syntax.Account.Plural.BeforeQueryPromise;
            including: Syntax.Account.Plural.IncludingQueryPromise;
            limitedTo: Syntax.Account.Plural.LimitedToQueryPromise;
            orderedBy: Syntax.Account.Plural.OrderedByQueryPromise;
            selecting: Syntax.Account.Plural.SelectingQueryPromise;
            to: Syntax.Account.Plural.ToQueryPromise;
            using: Syntax.Account.Plural.UsingQueryPromise;
            with: Syntax.Account.Plural.WithQueryPromise;
        };
    };
    namespace Account {
        type FieldSlug = "id" | "ronin.createdAt" | "ronin.createdBy" | "ronin.updatedAt" | "ronin.updatedBy" | "name" | "email" | "image";
        namespace Singular {
            type AfterQuery = Utils.AfterQuery<Account | null>;
            type AfterQueryPromise = Utils.AfterQueryPromise<Account | null>;
            type BeforeQuery = Utils.BeforeQuery<Account | null>;
            type BeforeQueryPromise = Utils.BeforeQueryPromise<Account | null>;
            type IncludingQuery = Utils.IncludingQuery<Account | null>;
            type IncludingQueryPromise = Utils.IncludingQueryPromise<Account | null>;
            type LimitedToQuery = Utils.LimitedToQuery<Account | null>;
            type LimitedToQueryPromise = Utils.LimitedToQueryPromise<Account | null>;
            type OrderedByQuery = Utils.OrderedByQuery<Account | null, Account.FieldSlug>;
            type OrderedByQueryPromise = Utils.OrderedByQueryPromise<Account | null, Account.FieldSlug>;
            type RootQueryCaller = Utils.RootQueryCaller<Account | null>;
            type RootQueryCallerPromise = Utils.RootQueryCallerPromise<Account | null>;
            type SelectingQuery = Utils.SelectingQuery<Account | null, Account.FieldSlug>;
            type SelectingQueryPromise = Utils.SelectingQueryPromise<Account | null, Account.FieldSlug>;
            type ToQuery = Utils.ToQuery<Account | null, Account>;
            type ToQueryPromise = Utils.ToQueryPromise<Account | null, Account>;
            type UsingQuery = ReducedFunction & (<T = Account | null>(value: CombinedInstructions["using"]) => T);
            type UsingQueryPromise = ReducedFunction & (<T = Account | null>(value: CombinedInstructions["using"]) => Promise<T>);
            type WithQuery = Utils.WithQuery<Account | null, Account> & {
                name: <T = Account | null>(name: Account["name"], options?: Record<string, unknown>) => T;
                email: <T = Account | null>(email: Account["email"], options?: Record<string, unknown>) => T;
                image: <T = Account | null>(image: Account["image"], options?: Record<string, unknown>) => T;
            };
            type WithQueryPromise = Utils.WithQueryPromise<Account | null, Account> & {
                name: <T = Account | null>(name: Account["name"], options?: Record<string, unknown>) => Promise<T>;
                email: <T = Account | null>(email: Account["email"], options?: Record<string, unknown>) => Promise<T>;
                image: <T = Account | null>(image: Account["image"], options?: Record<string, unknown>) => Promise<T>;
            };
        }
        namespace Plural {
            type AfterQuery = Utils.AfterQuery<Accounts>;
            type AfterQueryPromise = Utils.AfterQueryPromise<Accounts>;
            type BeforeQuery = Utils.BeforeQuery<Accounts>;
            type BeforeQueryPromise = Utils.BeforeQueryPromise<Accounts>;
            type IncludingQuery = Utils.IncludingQuery<Accounts>;
            type IncludingQueryPromise = Utils.IncludingQueryPromise<Accounts>;
            type LimitedToQuery = Utils.LimitedToQuery<Accounts>;
            type LimitedToQueryPromise = Utils.LimitedToQueryPromise<Accounts>;
            type OrderedByQuery = Utils.OrderedByQuery<Accounts, Account.FieldSlug>;
            type OrderedByQueryPromise = Utils.OrderedByQueryPromise<Accounts, Account.FieldSlug>;
            type RootQueryCaller = Utils.RootQueryCaller<Accounts>;
            type RootQueryCallerPromise = Utils.RootQueryCallerPromise<Accounts>;
            type SelectingQuery = Utils.SelectingQuery<Accounts, Account.FieldSlug>;
            type SelectingQueryPromise = Utils.SelectingQueryPromise<Accounts, Account.FieldSlug>;
            type ToQuery = Utils.ToQuery<Accounts, Account>;
            type ToQueryPromise = Utils.ToQueryPromise<Accounts, Account>;
            type UsingQuery = ReducedFunction & (<T = Accounts>(value: CombinedInstructions["using"]) => T);
            type UsingQueryPromise = ReducedFunction & (<T = Accounts>(value: CombinedInstructions["using"]) => Promise<T>);
            type WithQuery = Utils.WithQuery<Accounts, Account> & {
                name: <T = Accounts>(name: Account["name"], options?: Record<string, unknown>) => T;
                email: <T = Accounts>(email: Account["email"], options?: Record<string, unknown>) => T;
                image: <T = Accounts>(image: Account["image"], options?: Record<string, unknown>) => T;
            };
            type WithQueryPromise = Utils.WithQueryPromise<Accounts, Account> & {
                name: <T = Accounts>(name: Account["name"], options?: Record<string, unknown>) => Promise<T>;
                email: <T = Accounts>(email: Account["email"], options?: Record<string, unknown>) => Promise<T>;
                image: <T = Accounts>(image: Account["image"], options?: Record<string, unknown>) => Promise<T>;
            };
        }
    }
}
declare module "blade/types" {
    export interface TriggerOptions {
        client: {
            add: Syntax.AddQuery;
            get: Syntax.GetQuery;
            remove: Syntax.RemoveQuery;
            set: Syntax.SetQuery;
        };
    }
    export type Account = Utils.ResultRecord & {
        email: string;
        image: StoredObject;
        name: string;
    };
    export type Accounts = Array<Account> & {
        moreBefore?: string;
        moreAfter?: string;
    };
}
declare module "blade/server/hooks" {
    declare const use: Syntax.GetQuery;
}
declare module "blade/client/hooks" {
    declare const useMutation: () => {
        add: Syntax.AddQuery;
        remove: Syntax.RemoveQuery;
        set: Syntax.SetQuery;
    };
}
"
`;

exports[`generate with no models 1`] = `
"import type { CombinedInstructions, Expression } from "blade-compiler";
import type { ReducedFunction } from "blade/types";
import type {} from "blade/types";
export type {};
declare namespace Utils {
    type AfterQuery<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["after"], options?: Record<string, unknown>) => T);
    type AfterQueryPromise<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["after"], options?: Record<string, unknown>) => Promise<T>);
    type BeforeQuery<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["before"], options?: Record<string, unknown>) => T);
    type BeforeQueryPromise<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["before"], options?: Record<string, unknown>) => Promise<T>);
    type IncludingQuery<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["including"], options?: Record<string, unknown>) => T);
    type IncludingQueryPromise<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["including"], options?: Record<string, unknown>) => Promise<T>);
    type LimitedToQuery<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["limitedTo"], options?: Record<string, unknown>) => T);
    type LimitedToQueryPromise<U> = ReducedFunction & (<T = U>(value: CombinedInstructions["limitedTo"], options?: Record<string, unknown>) => Promise<T>);
    type OrderedByQuery<U, F extends string> = ReducedFunction & (<T = U>(instructions: {
        ascending?: Array<Expression | F>;
        descending?: Array<Expression | F>;
    }, options?: Record<string, unknown>) => T) & {
        ascending: <T = U>(fields: Array<Expression | F>, options?: Record<string, unknown>) => T;
        descending: <T = U>(fields: Array<Expression | F>, options?: Record<string, unknown>) => T;
    };
    type OrderedByQueryPromise<U, F extends string> = ReducedFunction & (<T = U>(instructions: {
        ascending?: Array<Expression | F>;
        descending?: Array<Expression | F>;
    }, options?: Record<string, unknown>) => Promise<T>) & {
        ascending: <T = U>(fields: Array<Expression | F>, options?: Record<string, unknown>) => Promise<T>;
        descending: <T = U>(fields: Array<Expression | F>, options?: Record<string, unknown>) => Promise<T>;
    };
    type ResultRecord = {
        /* The unique identifier of the record. */
        id: string;
        ronin: {
            /* The timestamp of when the record was created. */
            createdAt: string;
            /* The ID of the user who created the record. */
            createdBy: string | null;
            /* The timestamp of the last time the record was updated. */
            updatedAt: string;
            /* The ID of the user who last updated the record. */
            updatedBy: string | null;
        };
    };
    type RootQueryCaller<U> = <T = U>(instructions?: Partial<CombinedInstructions>, options?: Record<string, unknown>) => T;
    type RootQueryCallerPromise<U> = <T = U>(instructions?: Partial<CombinedInstructions>, options?: Record<string, unknown>) => Promise<T>;
    type SelectingQuery<U, F> = ReducedFunction & (<T = U>(instructions: Array<F>, options?: Record<string, unknown>) => T);
    type SelectingQueryPromise<U, F> = ReducedFunction & (<T = U>(instructions: Array<F>, options?: Record<string, unknown>) => Promise<T>);
    type ToQuery<U, S> = ReducedFunction & (<T = U>(instructions: Partial<S>, options?: Record<string, unknown>) => T);
    type ToQueryPromise<U, S> = ReducedFunction & (<T = U>(instructions: Partial<S>, options?: Record<string, unknown>) => Promise<T>);
    type WithQuery<U, S> = ReducedFunction & {
        <T = U>(instructions: Partial<S> | CombinedInstructions["with"], options?: Record<string, unknown>): T;
        id: <T = U>(value: ResultRecord["id"], options?: Record<string, unknown>) => T;
        ronin: ReducedFunction & {
            createdAt: <T = U>(value: ResultRecord["ronin"]["createdAt"], options?: Record<string, unknown>) => T;
            createdBy: <T = U>(value: ResultRecord["ronin"]["createdBy"], options?: Record<string, unknown>) => T;
            updatedAt: <T = U>(value: ResultRecord["ronin"]["updatedAt"], options?: Record<string, unknown>) => T;
            updatedBy: <T = U>(value: ResultRecord["ronin"]["updatedBy"], options?: Record<string, unknown>) => T;
        };
    };
    type WithQueryPromise<U, S> = ReducedFunction & {
        <T = U>(instructions: Partial<S> | CombinedInstructions["with"], options?: Record<string, unknown>): Promise<T>;
        id: <T = U>(value: ResultRecord["id"], options?: Record<string, unknown>) => Promise<T>;
        ronin: ReducedFunction & {
            createdAt: <T = U>(value: ResultRecord["ronin"]["createdAt"], options?: Record<string, unknown>) => Promise<T>;
            createdBy: <T = U>(value: ResultRecord["ronin"]["createdBy"], options?: Record<string, unknown>) => Promise<T>;
            updatedAt: <T = U>(value: ResultRecord["ronin"]["updatedAt"], options?: Record<string, unknown>) => Promise<T>;
            updatedBy: <T = U>(value: ResultRecord["ronin"]["updatedBy"], options?: Record<string, unknown>) => Promise<T>;
        };
    };
}
declare namespace Syntax {
    type AddQuery = {};
    type GetQuery = {};
    type RemoveQuery = {};
    type SetQuery = {};
}
declare module "blade/types" {
    export interface TriggerOptions {
        client: {
            add: Syntax.AddQuery;
            get: Syntax.GetQuery;
            remove: Syntax.RemoveQuery;
            set: Syntax.SetQuery;
        };
    }
}
declare module "blade/server/hooks" {
    declare const use: Syntax.GetQuery;
}
declare module "blade/client/hooks" {
    declare const useMutation: () => {
        add: Syntax.AddQuery;
        remove: Syntax.RemoveQuery;
        set: Syntax.SetQuery;
    };
}
"
`;
