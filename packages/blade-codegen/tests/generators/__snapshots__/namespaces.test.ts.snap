// Bun Snapshot v1, https://bun.sh/docs/test/snapshots

exports[`namespaces with a basic model 1`] = `
"namespace Account {
    type FieldSlug = "id" | "ronin.createdAt" | "ronin.createdBy" | "ronin.updatedAt" | "ronin.updatedBy" | "avatar" | "email" | "isActive" | "lastActiveAt" | "name" | "rewardPoints" | "settings";
    namespace Singular {
        type AfterQuery = Utils.AfterQuery<Account | null>;
        type AfterQueryPromise = Utils.AfterQueryPromise<Account | null>;
        type BeforeQuery = Utils.BeforeQuery<Account | null>;
        type BeforeQueryPromise = Utils.BeforeQueryPromise<Account | null>;
        type IncludingQuery = Utils.IncludingQuery<Account | null>;
        type IncludingQueryPromise = Utils.IncludingQueryPromise<Account | null>;
        type LimitedToQuery = Utils.LimitedToQuery<Account | null>;
        type LimitedToQueryPromise = Utils.LimitedToQueryPromise<Account | null>;
        type OrderedByQuery = Utils.OrderedByQuery<Account | null, Account.FieldSlug>;
        type OrderedByQueryPromise = Utils.OrderedByQueryPromise<Account | null, Account.FieldSlug>;
        type RootQueryCaller = Utils.RootQueryCaller<Account | null>;
        type RootQueryCallerPromise = Utils.RootQueryCallerPromise<Account | null>;
        type SelectingQuery = Utils.SelectingQuery<Account | null, Account.FieldSlug>;
        type SelectingQueryPromise = Utils.SelectingQueryPromise<Account | null, Account.FieldSlug>;
        type ToQuery = Utils.ToQuery<Account | null, Account>;
        type ToQueryPromise = Utils.ToQueryPromise<Account | null, Account>;
        type UsingQuery = ReducedFunction & (<T = Account | null>(value: CombinedInstructions["using"]) => T);
        type UsingQueryPromise = ReducedFunction & (<T = Account | null>(value: CombinedInstructions["using"]) => Promise<T>);
        type WithQuery = Utils.WithQuery<Account | null, Account> & {
            avatar: <T = Account | null>(avatar: Account["avatar"], options?: Record<string, unknown>) => T;
            email: <T = Account | null>(email: Account["email"], options?: Record<string, unknown>) => T;
            isActive: <T = Account | null>(isActive: Account["isActive"], options?: Record<string, unknown>) => T;
            lastActiveAt: <T = Account | null>(lastActiveAt: Account["lastActiveAt"], options?: Record<string, unknown>) => T;
            name: <T = Account | null>(name: Account["name"], options?: Record<string, unknown>) => T;
            rewardPoints: <T = Account | null>(rewardPoints: Account["rewardPoints"], options?: Record<string, unknown>) => T;
            settings: <T = Account | null>(settings: Account["settings"], options?: Record<string, unknown>) => T;
        };
        type WithQueryPromise = Utils.WithQueryPromise<Account | null, Account> & {
            avatar: <T = Account | null>(avatar: Account["avatar"], options?: Record<string, unknown>) => Promise<T>;
            email: <T = Account | null>(email: Account["email"], options?: Record<string, unknown>) => Promise<T>;
            isActive: <T = Account | null>(isActive: Account["isActive"], options?: Record<string, unknown>) => Promise<T>;
            lastActiveAt: <T = Account | null>(lastActiveAt: Account["lastActiveAt"], options?: Record<string, unknown>) => Promise<T>;
            name: <T = Account | null>(name: Account["name"], options?: Record<string, unknown>) => Promise<T>;
            rewardPoints: <T = Account | null>(rewardPoints: Account["rewardPoints"], options?: Record<string, unknown>) => Promise<T>;
            settings: <T = Account | null>(settings: Account["settings"], options?: Record<string, unknown>) => Promise<T>;
        };
    }
    namespace Plural {
        type AfterQuery = Utils.AfterQuery<Accounts>;
        type AfterQueryPromise = Utils.AfterQueryPromise<Accounts>;
        type BeforeQuery = Utils.BeforeQuery<Accounts>;
        type BeforeQueryPromise = Utils.BeforeQueryPromise<Accounts>;
        type IncludingQuery = Utils.IncludingQuery<Accounts>;
        type IncludingQueryPromise = Utils.IncludingQueryPromise<Accounts>;
        type LimitedToQuery = Utils.LimitedToQuery<Accounts>;
        type LimitedToQueryPromise = Utils.LimitedToQueryPromise<Accounts>;
        type OrderedByQuery = Utils.OrderedByQuery<Accounts, Account.FieldSlug>;
        type OrderedByQueryPromise = Utils.OrderedByQueryPromise<Accounts, Account.FieldSlug>;
        type RootQueryCaller = Utils.RootQueryCaller<Accounts>;
        type RootQueryCallerPromise = Utils.RootQueryCallerPromise<Accounts>;
        type SelectingQuery = Utils.SelectingQuery<Accounts, Account.FieldSlug>;
        type SelectingQueryPromise = Utils.SelectingQueryPromise<Accounts, Account.FieldSlug>;
        type ToQuery = Utils.ToQuery<Accounts, Account>;
        type ToQueryPromise = Utils.ToQueryPromise<Accounts, Account>;
        type UsingQuery = ReducedFunction & (<T = Accounts>(value: CombinedInstructions["using"]) => T);
        type UsingQueryPromise = ReducedFunction & (<T = Accounts>(value: CombinedInstructions["using"]) => Promise<T>);
        type WithQuery = Utils.WithQuery<Accounts, Account> & {
            avatar: <T = Accounts>(avatar: Account["avatar"], options?: Record<string, unknown>) => T;
            email: <T = Accounts>(email: Account["email"], options?: Record<string, unknown>) => T;
            isActive: <T = Accounts>(isActive: Account["isActive"], options?: Record<string, unknown>) => T;
            lastActiveAt: <T = Accounts>(lastActiveAt: Account["lastActiveAt"], options?: Record<string, unknown>) => T;
            name: <T = Accounts>(name: Account["name"], options?: Record<string, unknown>) => T;
            rewardPoints: <T = Accounts>(rewardPoints: Account["rewardPoints"], options?: Record<string, unknown>) => T;
            settings: <T = Accounts>(settings: Account["settings"], options?: Record<string, unknown>) => T;
        };
        type WithQueryPromise = Utils.WithQueryPromise<Accounts, Account> & {
            avatar: <T = Accounts>(avatar: Account["avatar"], options?: Record<string, unknown>) => Promise<T>;
            email: <T = Accounts>(email: Account["email"], options?: Record<string, unknown>) => Promise<T>;
            isActive: <T = Accounts>(isActive: Account["isActive"], options?: Record<string, unknown>) => Promise<T>;
            lastActiveAt: <T = Accounts>(lastActiveAt: Account["lastActiveAt"], options?: Record<string, unknown>) => Promise<T>;
            name: <T = Accounts>(name: Account["name"], options?: Record<string, unknown>) => Promise<T>;
            rewardPoints: <T = Accounts>(rewardPoints: Account["rewardPoints"], options?: Record<string, unknown>) => Promise<T>;
            settings: <T = Accounts>(settings: Account["settings"], options?: Record<string, unknown>) => Promise<T>;
        };
    }
}
"
`;

exports[`namespaces with a link field 1`] = `
"namespace Account {
    type FieldSlug = "id" | "ronin.createdAt" | "ronin.createdBy" | "ronin.updatedAt" | "ronin.updatedBy" | "name" | "email";
    namespace Singular {
        type AfterQuery = Utils.AfterQuery<Account | null>;
        type AfterQueryPromise = Utils.AfterQueryPromise<Account | null>;
        type BeforeQuery = Utils.BeforeQuery<Account | null>;
        type BeforeQueryPromise = Utils.BeforeQueryPromise<Account | null>;
        type IncludingQuery = Utils.IncludingQuery<Account | null>;
        type IncludingQueryPromise = Utils.IncludingQueryPromise<Account | null>;
        type LimitedToQuery = Utils.LimitedToQuery<Account | null>;
        type LimitedToQueryPromise = Utils.LimitedToQueryPromise<Account | null>;
        type OrderedByQuery = Utils.OrderedByQuery<Account | null, Account.FieldSlug>;
        type OrderedByQueryPromise = Utils.OrderedByQueryPromise<Account | null, Account.FieldSlug>;
        type RootQueryCaller = Utils.RootQueryCaller<Account | null>;
        type RootQueryCallerPromise = Utils.RootQueryCallerPromise<Account | null>;
        type SelectingQuery = Utils.SelectingQuery<Account | null, Account.FieldSlug>;
        type SelectingQueryPromise = Utils.SelectingQueryPromise<Account | null, Account.FieldSlug>;
        type ToQuery = Utils.ToQuery<Account | null, Account>;
        type ToQueryPromise = Utils.ToQueryPromise<Account | null, Account>;
        type UsingQuery = ReducedFunction & (<T = Account | null>(value: CombinedInstructions["using"]) => T);
        type UsingQueryPromise = ReducedFunction & (<T = Account | null>(value: CombinedInstructions["using"]) => Promise<T>);
        type WithQuery = Utils.WithQuery<Account | null, Account> & {
            name: <T = Account | null>(name: Account["name"], options?: Record<string, unknown>) => T;
            email: <T = Account | null>(email: Account["email"], options?: Record<string, unknown>) => T;
        };
        type WithQueryPromise = Utils.WithQueryPromise<Account | null, Account> & {
            name: <T = Account | null>(name: Account["name"], options?: Record<string, unknown>) => Promise<T>;
            email: <T = Account | null>(email: Account["email"], options?: Record<string, unknown>) => Promise<T>;
        };
    }
    namespace Plural {
        type AfterQuery = Utils.AfterQuery<Accounts>;
        type AfterQueryPromise = Utils.AfterQueryPromise<Accounts>;
        type BeforeQuery = Utils.BeforeQuery<Accounts>;
        type BeforeQueryPromise = Utils.BeforeQueryPromise<Accounts>;
        type IncludingQuery = Utils.IncludingQuery<Accounts>;
        type IncludingQueryPromise = Utils.IncludingQueryPromise<Accounts>;
        type LimitedToQuery = Utils.LimitedToQuery<Accounts>;
        type LimitedToQueryPromise = Utils.LimitedToQueryPromise<Accounts>;
        type OrderedByQuery = Utils.OrderedByQuery<Accounts, Account.FieldSlug>;
        type OrderedByQueryPromise = Utils.OrderedByQueryPromise<Accounts, Account.FieldSlug>;
        type RootQueryCaller = Utils.RootQueryCaller<Accounts>;
        type RootQueryCallerPromise = Utils.RootQueryCallerPromise<Accounts>;
        type SelectingQuery = Utils.SelectingQuery<Accounts, Account.FieldSlug>;
        type SelectingQueryPromise = Utils.SelectingQueryPromise<Accounts, Account.FieldSlug>;
        type ToQuery = Utils.ToQuery<Accounts, Account>;
        type ToQueryPromise = Utils.ToQueryPromise<Accounts, Account>;
        type UsingQuery = ReducedFunction & (<T = Accounts>(value: CombinedInstructions["using"]) => T);
        type UsingQueryPromise = ReducedFunction & (<T = Accounts>(value: CombinedInstructions["using"]) => Promise<T>);
        type WithQuery = Utils.WithQuery<Accounts, Account> & {
            name: <T = Accounts>(name: Account["name"], options?: Record<string, unknown>) => T;
            email: <T = Accounts>(email: Account["email"], options?: Record<string, unknown>) => T;
        };
        type WithQueryPromise = Utils.WithQueryPromise<Accounts, Account> & {
            name: <T = Accounts>(name: Account["name"], options?: Record<string, unknown>) => Promise<T>;
            email: <T = Accounts>(email: Account["email"], options?: Record<string, unknown>) => Promise<T>;
        };
    }
}
namespace Post {
    type FieldSlug = "id" | "ronin.createdAt" | "ronin.createdBy" | "ronin.updatedAt" | "ronin.updatedBy" | "title" | "author";
    namespace Singular {
        type AfterQuery = Utils.AfterQuery<Post | null>;
        type AfterQueryPromise = Utils.AfterQueryPromise<Post | null>;
        type BeforeQuery = Utils.BeforeQuery<Post | null>;
        type BeforeQueryPromise = Utils.BeforeQueryPromise<Post | null>;
        type IncludingQuery = Utils.IncludingQuery<Post | null>;
        type IncludingQueryPromise = Utils.IncludingQueryPromise<Post | null>;
        type LimitedToQuery = Utils.LimitedToQuery<Post | null>;
        type LimitedToQueryPromise = Utils.LimitedToQueryPromise<Post | null>;
        type OrderedByQuery = Utils.OrderedByQuery<Post | null, Post.FieldSlug>;
        type OrderedByQueryPromise = Utils.OrderedByQueryPromise<Post | null, Post.FieldSlug>;
        type RootQueryCaller = Utils.RootQueryCaller<Post | null>;
        type RootQueryCallerPromise = Utils.RootQueryCallerPromise<Post | null>;
        type SelectingQuery = Utils.SelectingQuery<Post | null, Post.FieldSlug>;
        type SelectingQueryPromise = Utils.SelectingQueryPromise<Post | null, Post.FieldSlug>;
        type ToQuery = Utils.ToQuery<Post | null, Post>;
        type ToQueryPromise = Utils.ToQueryPromise<Post | null, Post>;
        type UsingQuery = ReducedFunction & {
            <U extends Array<"author"> | "all">(fields: U): Post<U> | null;
            <T = Post | null>(fields: Array<"author"> | "all"): T;
        };
        type UsingQueryPromise = ReducedFunction & {
            <U extends Array<"author"> | "all">(fields: U): Promise<Post<U>> | null;
            <T = Post | null>(fields: Array<"author"> | "all"): Promise<T>;
        };
        type WithQuery = Utils.WithQuery<Post | null, Post> & {
            title: <T = Post | null>(title: Post["title"], options?: Record<string, unknown>) => T;
            author: <T = Post | null>(author: Post["author"] | Partial<Post<[
                "author"
            ]>["author"]>, options?: Record<string, unknown>) => T;
        };
        type WithQueryPromise = Utils.WithQueryPromise<Post | null, Post> & {
            title: <T = Post | null>(title: Post["title"], options?: Record<string, unknown>) => Promise<T>;
            author: <T = Post | null>(author: Post["author"] | Partial<Post<[
                "author"
            ]>["author"]>, options?: Record<string, unknown>) => Promise<T>;
        };
    }
    namespace Plural {
        type AfterQuery = Utils.AfterQuery<Posts>;
        type AfterQueryPromise = Utils.AfterQueryPromise<Posts>;
        type BeforeQuery = Utils.BeforeQuery<Posts>;
        type BeforeQueryPromise = Utils.BeforeQueryPromise<Posts>;
        type IncludingQuery = Utils.IncludingQuery<Posts>;
        type IncludingQueryPromise = Utils.IncludingQueryPromise<Posts>;
        type LimitedToQuery = Utils.LimitedToQuery<Posts>;
        type LimitedToQueryPromise = Utils.LimitedToQueryPromise<Posts>;
        type OrderedByQuery = Utils.OrderedByQuery<Posts, Post.FieldSlug>;
        type OrderedByQueryPromise = Utils.OrderedByQueryPromise<Posts, Post.FieldSlug>;
        type RootQueryCaller = Utils.RootQueryCaller<Posts>;
        type RootQueryCallerPromise = Utils.RootQueryCallerPromise<Posts>;
        type SelectingQuery = Utils.SelectingQuery<Posts, Post.FieldSlug>;
        type SelectingQueryPromise = Utils.SelectingQueryPromise<Posts, Post.FieldSlug>;
        type ToQuery = Utils.ToQuery<Posts, Post>;
        type ToQueryPromise = Utils.ToQueryPromise<Posts, Post>;
        type UsingQuery = ReducedFunction & {
            <U extends Array<"author"> | "all">(fields: U): Post<U>;
            <T = Posts>(fields: Array<"author"> | "all"): T;
        };
        type UsingQueryPromise = ReducedFunction & {
            <U extends Array<"author"> | "all">(fields: U): Promise<Post<U>>;
            <T = Posts>(fields: Array<"author"> | "all"): Promise<T>;
        };
        type WithQuery = Utils.WithQuery<Posts, Post> & {
            title: <T = Posts>(title: Post["title"], options?: Record<string, unknown>) => T;
            author: <T = Posts>(author: Post["author"] | Partial<Post<[
                "author"
            ]>["author"]>, options?: Record<string, unknown>) => T;
        };
        type WithQueryPromise = Utils.WithQueryPromise<Posts, Post> & {
            title: <T = Posts>(title: Post["title"], options?: Record<string, unknown>) => Promise<T>;
            author: <T = Posts>(author: Post["author"] | Partial<Post<[
                "author"
            ]>["author"]>, options?: Record<string, unknown>) => Promise<T>;
        };
    }
}
"
`;

exports[`namespaces with no models 1`] = `""`;
