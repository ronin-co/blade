---
title: Triggers
---

import { AlertCard } from "@/components/alert";

# Triggers

To perform additional operations when a particular kind of query is executed on your
database, you can define database triggers.

Database triggers are TypeScript functions that are executed for incoming Blade queries,
and can be used to validate those queries, run additional queries within the same
transaction, run asynchronous code, or load data from a different data source.

They are modeled after [SQLite triggers](https://sqlite.org/lang_createtrigger.html)
and mostly behave in the same way, except for adding additional functionality
through the function arguments that are provided to triggers.

## Defining Triggers

To get started with locally developing database triggers, create a `triggers` directory
at the root of your project. Within it, create a file with the slug of the
[model](/models) that you would like to address with your triggers.

For example, if the slug of your model is `chatMessage`, you could add the file below.

While the slugs of [models](/models) are [camel-case](https://developer.mozilla.org/en-US/docs/Glossary/Camel_case) (that's how properties are defined
in JavaScript), the file names of triggers are [kebab-case](https://developer.mozilla.org/en-US/docs/Glossary/Kebab_case) (that's the most common file naming convention in the JavaScript ecosystem and prevents issues on [case-insensitive](https://en.wikipedia.org/wiki/Case_sensitivity) file systems).

```ts
// triggers/chat-message.ts

import { triggers } from 'blade/schema';
import type { Account } from 'blade/types';

export default triggers<Account>({
  add: ({ query }) => {
    query.with.handle = query.with.name.toLowerCase();
    // Run more code here
    return query;
  }
});
```

As an example, the trigger above would automatically run for every query of type `add`
and auto-generate a value for the `handle` field based on the value of the `name` field.
In other words, the `handle` of every newly created `account` record would not contain
the name of the account, in lower-case text.

To test it, you could run the following query with the
[`useMutation`](#usemetadata-server) hook:

```ts
await add.account.with.name('Engineering');
```

## When to use Triggers

In general, you should refrain from using triggers for anything that can be accomplished
using [model definitions](/models), to ensure the best performance and
maintainability of your queries.

For example, if you need to provide any form of static defaults for your queries (meaning
defaults that are the same for every query), you should define them in the model
definition itself, using the `defaultValue` attribute of fields, for example. Like that,
no unnecessary computational step will happen for your queries.

Even if a value is dynamic, such as a mathematic equation, as long as it does not depend
on the value of another field, and assuming that it always produces the same output
(meaning it is [deterministic](https://en.wikipedia.org/wiki/Deterministic_system)), you
should still define it in your model definition.

For any use case that is highly dynamic, or that simply cannot be accomplished using the
model definition, you can use database triggers, which perform computation for every
query that is affected.

## Types of Triggers

Blade supports 2 types of triggers:

- **Synchronous Triggers**: These functions return queries that are executed within the
  same transaction as the original query. Either before the original query, after it, or
  instead of it.
- **Asynchronous Triggers:** These functions are executed separately from the database
  transaction, and can be used to load data from a third-party data source, or run
  asynchronous code.

In the majority of cases, you will want to use Synchronous Triggers, which let you write
arbitrary synchronos code that does not perform any
[I/O](https://en.wikipedia.org/wiki/Input/output) (e.g. no network requests) and purely
validate queries, transform queries, or augment them with additional surrounding queries.

In certain cases, if you really need to run asynchronous code, you can do so using
Asynchronous Triggers, but in such cases, you should be careful to write efficient code
that, for example, doesn't cause any unnecessary
[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) waterfalls.

## Synchronous Triggers

The following methods are available for defining synchronous triggers:

### Before

These triggers provide queries that are executed before the original query is executed,
within the same transaction. They can be used to create additional resources in the
database. For example, if a query depends on a parent record to get created first, you
may create that parent record in a `before*` trigger.

They can return multiple queries and must return at least one query.

```ts
import { triggers } from 'blade/schema';

export default triggers({
  beforeAdd: ({ client }) => {
    const { add } = client;

    return [
      add.team.with.name('Engineering')
    ];
  }
});
```

#### Methods

- `beforeGet`: Executed before a `get` query.
- `beforeCount`: Executed before a `count` query.
- `beforeAdd`: Executed before an `add` query.
- `beforeSet`: Executed before an `set` query.
- `beforeRemove`: Executed before a `remove` query.

### During

These triggers are executed instead of the original query, within the same transaction.
They can be used to validate the original query, or transform it by modifying its
[query instructions](/queries/instructions).

They must return exactly one query.

```ts
import { triggers } from 'blade/schema';

export default triggers({
  add: ({ query }) => {
    // Modify the query
    return query;
  }
});
```

#### Methods

- `get`: Executed instead of a `get` query.
- `count`: Executed instead of a `count` query.
- `add`: Executed instead of an `add` query.
- `set`: Executed instead of an `set` query.
- `remove`: Executed instead of a `remove` query.

### After

These triggers provide queries that are executed after the original query is executed,
within the same transaction. They can be used to create additional resources in the
database. For example, if a query depends on a child record to get created after it, you
may create that child record in a `after*` trigger.

They can return multiple queries and must return at least one query.

```ts
import { triggers } from 'blade/schema';

export default triggers({
  afterAdd: ({ client }) => {
    const { add } = client;

    return [
      add.member.with.account(1234)
    ];
  }
});
```

#### Methods

- `afterGet`: Executed after a `get` query.
- `afterCount`: Executed after a `count` query.
- `afterAdd`: Executed after an `add` query.
- `afterSet`: Executed after an `set` query.
- `afterRemove`: Executed after a `remove` query.

## Asynchronous Triggers

The following methods are available for defining asynchronous triggers:

### Resolving

These triggers are executed instead of the original query and prevent the original query
from reaching the database. They can therefore be used to load data from a third-party
data source via a network request, and return it from the trigger.

```ts
import { triggers } from 'blade/schema';

export default triggers({
  resolvingAdd: async (options) => {
    return { testField: 'testValue', anotherField: 'anotherValue' };
  }
});
```

#### Methods

- `resolvingGet`: Executed for a `get` query.
- `resolvingCount`: Executed for a `count` query.
- `resolvingAdd`: Executed for an `add` query.
- `resolvingSet`: Executed for an `set` query.
- `resolvingRemove`: Executed for a `remove` query.

### Following

These triggers are executed after the original query is executed, meaning after the
transaction of the original query was fully committed to the database. They can be used
to run asynchronous code, such as sending a notification to a third-party service every
time a record is added to the database.

```ts
import { triggers } from 'blade/schema';

export default triggers({
  followingAdd: async (options) => {
    // Run code that should not slow down the original query
  }
});
```

As you can see, the triggers of type `following` are provided two extra function
arguments, which all other types of triggers do not receive: The arguments `before` and
`after` contain the state of the records that were affected by the original query, before
and after the query was executed.

This is useful for generating custom audit logs for your application, for example, since
it allows for diffing the field values of a record.

#### Methods

Unlike the other types of triggers, triggers of type `following` can only be defined for
[query types](/queries/crud) that write data. They cannot be defined for query
types that read data, such as `get` or `count`.

- `followingAdd`: Executed after an `add` query.
- `followingSet`: Executed after an `set` query.
- `followingRemove`: Executed after a `remove` query.

## Trigger Arguments

The following options are available for all triggers:

- `query`: An object containing the [instructions](/queries/instructions)
  of the query that is being executed. The argument neither contains the
  [type](/queries/crud) of the query, nor the
  [target](/docs/queries/targets) of the query. It only contains the
  instructions of the query. The type and target are already evident from the
  name of the trigger and the model for which it was defined.
- `multipleRecords`: A boolean indicating whether the query targets multiple records
  or a single record. For example, a query such as `get.team()` would result in
  this argument being `false`, while a query such as `get.teams()` would result
  in this argument being `true`.
- `parentTrigger`: Indicates whether the query was generated by another trigger. If it
  was, the property will contain its model slug and its trigger type.
- `headless`: Indicates whether the query is coming from "the outside", meaning either
  from the [client-side of Blade](/hooks#usemutation-client) or the auto-generated
  [REST API](/api-routes#api-routes). In those cases, you should consider
  the query insecure (not trustworthy), since it could've been modified by the device that
  sent it. If the option is set to `false`, the query can be considered secure, since it
  stems from the "inside", meaning the server.
- `client`: Contains methods for running [Nested Queries](#Nested%20Queries).
- `waitUntil`: A function to which a promise can be passed. Blade will keep the worker
  alive until the promise has either been resolved or rejected.
- `cookies`: An object containing all cookies of the request that ran the query.
- `setCookie`: A function that can be used to add, update, or remove a cookie. It takes
  the same arguments as the cookie setting function offered by
  the [useCookie](/hooks#usecookie) hook.
- `context`: A `Map` used for sharing arbitrary values between triggers.
- `previousRecords`: Only available for triggers of type [Following](#Following).
- `records`: Only available for triggers of type [Following](#Following).

Additional options are available for [Sink](#Trigger%20Sink) triggers.

## Trigger Context

In order to share arbitrary values between the triggers of a model, you can store them
in the `context` map, which is provided to every trigger:

```typescript
import { triggers } from 'blade/schema';

export default triggers({
  add: ({ query, context }) => {
    context.set('test', query.with.ephemeralField);
    delete query.with.ephemeralField;

    return query;
  },

  afterAdd = ({ context, client }) => {
    const value = context.get('test');
    const { add } = client;

    return [
      add.record.with.content(value)
    ];
  };
});
```

In the example above, a write query containing a field named `ephemeralField` field
is executed on the client. This field does not exist in the model, so it cannot be
stored, but it was provided to the query regardless, which makes it a so-called
"ephemeral field".

The term describes fields that are provided as part of a query,
but not actually stored in the database, because they are stripped in a trigger.
This allows for providing triggers with values that should not be stored in the database.

Ephemeral fields must be stripped in triggers of type [during](#during), to ensure
that they will not be stored in the database. After stripping such a field, you could
then either use it inside that same trigger, or use trigger context to make the
value of the stripped field available to any triggers after the current one.

## Nested Queries

To run additional queries whenever a particular query is executed, you can define
[before](#Before) and [after](#After) triggers, which allow for executing additional
queries in the same transaction as the original query.

Doing so avoids [I/O](https://en.wikipedia.org/wiki/Input/output) waterfalls, since the
database is only invoked once, executes all queries of the transaction and then returns
all results at once. This ensures that your original query is executed as quickly
as possible.

In the rare cases in which you do need to query additional data within triggers, however,
you can do so using the `client` property of the `options` argument that is passed to the
trigger. This property contains the instance of the client that is currently being used
to execute the query, and can be used to run additional queries within the trigger:

```ts
import { triggers } from 'blade/schema';

export default triggers({
  add: async ({ client }) => {
    const { get } = client;
    const anotherRecord = await get.team.with.id(1234);

    // Modify the query
    return query;
  }
});
```

## Trigger Sink

<AlertCard>
  Multiple databases per RONIN space are currently in private beta and not yet publicly available.
</AlertCard>

When executing a query, the client allows for providing a config option named
`database`, which can be used to target a specific database within the RONIN space:

```ts
await add.team.with.name('Engineering', { database: 'my-database' });
```

Queries for which this config option was defined do not cause any triggers to be executed
by default. Instead, such queries must be explicitly captured using a special trigger
named "sink":

```ts
// triggers/sink.ts

import { triggers } from 'blade/schema';

export default triggers({
  get: ({ model, database }) => {
    // This trigger is executed for queries that target a specific database.
    return query;
  },
});
```

Specifically, as you can see above, sink triggers are using the word "sink" in place of
the model slug. This is because sink triggers capture all queries of all models.

Additionally, sink queries receive additional properties within the `options` object that
allow for identifying the original query more easily. A `model` property contains the
slug of the model that was targeted, and a `database` property contains the slug of the
database that was targeted.

## Trigger Errors

To make creating triggers as easy as possible, Blade provides a list of default errors
that can be thrown from triggers and used on the client-side to assert specific behavior.

```ts
import {
  TriggerError,
  InvalidFieldsError,
  EmptyFieldsError,
  ExtraneousFieldsError,
  RecordExistsError,
  RecordNotFoundError,
  TooManyRequestsError,
  InvalidPermissionsError,
  AddNotAllowedError,
  SetNotAllowedError,
  RemoveNotAllowedError,
  MultipleWithInstructionsError,

  ClientError,
  CompilerError
} from 'blade/server';
```

On the client, you can then use the following pattern to match against those errors:

```ts
import { InvalidFieldsError } from 'blade/server';

if (err instanceof InvalidFieldsError) {
  // Run logic
}
```