---
title: Models
---

import {
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";

# Models

The schema of your database consistents of multiple models. Each model uses fields to define the shape of a particular kind of record in your database.

For example, your database schema might contain a model called "Account" representing a user, and a model called "Team", representing a group of users.

When using Blade, your database schema is defined in code, which provides maximum flexibility and benefits such as **revisions**, **reviews** and **reverts** via Git. This page provides an overview of how to define your database schema in code.

## Defining Models

At the root of your project, start by creating the file that will contain your model definitions:

```bash title="Terminal"
mkdir schema
touch schema/index.ts
```

A model is defined using the `model()` function provided under the `blade/schema` path. The path also provides all field type primitives, such as `string()`, `number()`, or `blob()`.

Here is an example of a basic schema definition:

```ts title="schema/index.ts"
import { model, string, date } from 'blade/schema';

export const Account = model({
  slug: 'account',

  fields: {
    name: string(),
    handle: string(),
    verifiedAt: date()
  }
});
```

In the example above, we defined a model named `Account` with three fields: `name`, `handle`, and `verifiedAt`. Each field is defined using a key-value pair where the key is the slug of the field and the value is the type of the field. See all available field types in the [Field Types](#Field%20Types) section.

Once you've defined your models, you can compare them to the current state of your database:

```bash title="Terminal"
blade diff
```

Running the command above will produce a so-called "migration protocol" in the `.ronin` directory. This protocol contains all the steps required to update your database to match your local schema definition.

To apply the changes to your database, run the following command:

```bash title="Terminal"
blade apply
```

Afterward, you can start sending queries to your database that make use of the newly added (or updated) models in your database schema.

In the future, if you'd like to immediately apply your local changes to your database without first reviewing them, run this command:

```bash title="Terminal"
blade diff --apply
```

Like this, the generated migration protocol will be applied immediately, without you being able to review it first. This can be especially useful during development as it maximizes efficiency, but we recommend against applying migrations without reviewing them in production.

In general, when working in a team, you most likely want to run `blade diff` in order to generate a migration protocol for your change, commit it to a pull request together with your schema change, have it be reviewed by your team, and then run `blade apply` after the pull request was approved.

An update will also be provided in the future to automatically apply migrations that were merged onto the `main` branch of your repository, so that you don't need to run `blade apply` yourself.

## Field Types

The following types can be used to define fields in a model:

<Table>
  <TableHeader>
    <TableRow>
      <TableHead className="w-[100px]">Function</TableHead>
      <TableHead>Type</TableHead>
    </TableRow>
  </TableHeader>
  <TableBody>
    <TableRow>
      <TableCell>`string()`</TableCell>
      <TableCell>String field</TableCell>
    </TableRow>
    <TableRow>
      <TableCell>`number()`</TableCell>
      <TableCell>Number field</TableCell>
    </TableRow>
    <TableRow>
      <TableCell>`boolean()`</TableCell>
      <TableCell>Boolean field</TableCell>
    </TableRow>
    <TableRow>
      <TableCell>`date()`</TableCell>
      <TableCell>Timestamp field</TableCell>
    </TableRow>
    <TableRow>
      <TableCell>`blob()`</TableCell>
      <TableCell>Binary object field</TableCell>
    </TableRow>
    <TableRow>
      <TableCell>`json()`</TableCell>
      <TableCell>JSON field</TableCell>
    </TableRow>
  </TableBody>
</Table>

[Learn more](/models/fields) about how to apply the individual field types.

## Formatting

Slugs of models and fields must be provided in [camel case](https://en.wikipedia.org/wiki/Camel_case), since Blade queries are written in TypeScript and camel case is the common formatting choice for property names in the TypeScript ecosystem.

For example, the following slug would be allowed for models:

```plaintext
productCategory
```

While the following are **not allowed**:

```plaintext
product_category
product category
ProductCategory
```

## Multiple Apps

If you are maintaining multiple Blade applications that are accessing the same database, make sure to designate only a single application as the "source of truth" in your team. In other words, the commands `blade diff` and `blade apply` should only be run in a single application per database.

After every update to the database schema, you could then run `blade pull` in all other applications where that same database schema is used, which will re-generate the local model definitions from the current state of the remote database.

A future update to Blade will make it possible to run queries from multiple apps without repeating the database schema source code in each one of those applications.